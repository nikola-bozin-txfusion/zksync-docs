---
title: Migrating deploy scripts to the ZKsync
description: Learn how to migrate an existing Hardhat project deploy scripts to ZKsync Era.
---

This quick guide shows you how to migrate the scripts and processes of an existing Hardhat project to ZKsync.
If you are not familiar with our plugins, network, and compiler setup, please check the full migration guide 20.migrating-to-zksync.md.

To install the complete set of ZKsync-specific packages, simply install the `hardhat-zksync` umbrella plugin.

::code-group

```bash [npm]
npm i -D @matterlabs/hardhat-zksync
```

```bash [yarn]
yarn add -D @matterlabs/hardhat-zksync
```

```bash [pnpm]
pnpm i -D @matterlabs/hardhat-zksync
```

```bash [bun]
bun add @matterlabs/hardhat-zksync
```

::

In the `hardhat.config.ts` file import the installed dependencies:

```ts
import "@matterlabs/hardhat-zksync";
```

## Migrating from hardhat-ethers to hardhat-zksync-ethers

### Deployment

Deployment of a simple contracts is quite straight forward.

::code-group

```typescript [hardhat-ethers]
const greeter = await hre.ethers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const greeter = await hre.zksyncEthers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

::

In-case a custom deployment is needed, use `ContractFactory`.

::code-group

```typescript [hardhat-zksync-ethers]
const GreeterFactory = await hre.ethers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const GreeterFactory = await hre.zksyncEthers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

::

## Migrating from @openzeppelin/contracts-upgradable to hardhat-zksync-upgradeable

Deployment and upgrade functionalities of proxies has full interface compatability with @openzeppelin/contracts-upgradeable.

#### Deployment (proxy)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployProxy(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.zkEthers.getContractFactory("Box");
const box = await hre.zkUpgrades.deployProxy(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Proxy)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.zkEthers.getContractFactory("BoxV2");
const boxV2 = await hre.zkUpgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

#### Deployment (beacon)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployBeacon(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.zkEthers.getContractFactory("Box");
const box = await hre.zkUpgrades.deployBeacon(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Beacon)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.zkEthers.getContractFactory("BoxV2");
const boxV2 = await hre.zkUpgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

### hardhat-deploy

The latest updates to Hardhat's deploy plugin now includes support for deployment on the ZKsync L2 network.

### Smart Contract Verification

For ZKsync, the verification of a smart contracts does not differ from the commonly used verification process.

By installing `@matterlabs/hardhat-zksync`, a verification plugin is automatically added and ready to be used.

The only thing that is required to be modified is `hardhat.config.ts` file to include `verifyURL` in the network section.

::code-group

```typescript [url-zksync-sepolia-testnet]
  zkSyncSepoliaTestnet: {
    url: "https://sepolia.era.zksync.dev",
    ethNetwork: "sepolia",
    zksync: true,
    verifyURL: 'https://explorer.sepolia.era.zksync.dev/contract_verification'
  }
```

```typescript [url-zksync-mainnet]
  zkSyncMainnet: {
    url: "https://mainnet.era.zksync.io",
    ethNetwork: "mainnet",
    zksync: true,
    verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
  },
```

::

Now the verification process can either be run trough terminal command or in code.

#### Non-inline Libraries

Deploying non-inline libraries on ZKsync Network is done in a different way.

If your project contains non-inline libraries, command will fail.

::code-group

```bash [npm]
npm hardhat compile
```

```bash [yarn]
yarn hardhat compile
```

```bash [pnpm]
pnpm hardhat compile
```

```bash [bun]
bun hardhat compile
```

::

Now deployment script can be executed and for selected network it will deploy all missing libraries and continue with deployment scripts.

::code-group

```typescript [hardhat-ethers]
const firstLibrary = await hre.ethers.deployContract("LibraryA");
await firstLibrary.waitForDeployment();
const firstLibraryAddress = await firstLibrary.getAddress()

const secondLibrary = await hre.ethers.deployContract("LibraryB");
await secondLibrary.waitForDeployment();
const secondLibraryAddress = await l2.getAddress();

const mainContract = await hre.ethers.deployContract("MainContract",{
  libraries:{
    LibraryA:firstLibraryAddress,
    LibraryB:secondLibraryAddress
  }
});

await mainContract.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const mainContract = await hre.zkEthers.deployContract("MainContract")
await mainContract.waitForDeployment();
```

::
